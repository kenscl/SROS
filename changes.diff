diff --git a/CMakeLists.txt b/CMakeLists.txt
index 08c0988..0ab6c15 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -20,7 +20,7 @@ include(${PLATFORM_CONFIG_FILE})
 set(TARGET_NAME SROS)
 
 file(GLOB C_SOURCES ${CMAKE_SOURCE_DIR}/src/*.c ${HAL_FILES_C} ${CMAKE_SOURCE_DIR}/src/krnl/*.c ${CMAKE_SOURCE_DIR}/src/hal/*.c ${CMAKE_SOURCE_DIR}/src/communication/*.c ${CMAKE_SOURCE_DIR}/src/math/*.c)
-file(GLOB CPP_SOURCES ${CMAKE_SOURCE_DIR}/src/*.cpp ${HAL_FILES_CPP} ${CMAKE_SOURCE_DIR}/src/krnl/*.cpp ${CMAKE_SOURCE_DIR}/src/hal/*.cpp ${CMAKE_SOURCE_DIR}/src/communication/*.cpp ${CMAKE_SOURCE_DIR}/src/math/*.cpp)
+file(GLOB CPP_SOURCES ${CMAKE_SOURCE_DIR}/src/*.cpp ${HAL_FILES_CPP} ${CMAKE_SOURCE_DIR}/src/krnl/*.cpp ${CMAKE_SOURCE_DIR}/src/hal/*.cpp ${CMAKE_SOURCE_DIR}/src/communication/*.cpp ${CMAKE_SOURCE_DIR}/src/math/*.cpp ${CMAKE_SOURCE_DIR}/src/attitude/*.cpp)
 set(SOURCES ${C_SOURCES} ${CPP_SOURCES} ${OUTHER_SOURCES})
 
 add_executable(${TARGET_NAME}.elf ${SOURCES})
diff --git a/README.md b/README.md
index 4918285..0d15f3c 100644
--- a/README.md
+++ b/README.md
@@ -14,10 +14,20 @@ For STM32F407G:
 ``` bash
 cmake -DPLATFORM_CONFIG_FILE=platform/stm32f407.cmake ..
 ```
+
 For STM32F103:
 ``` bash
 cmake -DPLATFORM_CONFIG_FILE=platform/stm32f103.cmake ..
 ```
+
+You might also want to add the `compile_commands.json` file depending on your ide:
+``` bash
+cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DPLATFORM_CONFIG_FILE=platform/stm32f407.cmake ..
+```
+or 
+``` bash
+cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DPLATFORM_CONFIG_FILE=platform/stm32f103.cmake ..
+```
 You can then build the project with:
 ``` bash
 make
@@ -38,7 +48,7 @@ includes the header (the implementation may also be done in the header).
 To define the thread simply use a method that never returns, for example:
 
 ``` c
-void template_thread () {
+volatile void template_thread () {
   // variable initialisation
   while (1) {
 	  // your code
diff --git a/platform/stm32f407.cmake b/platform/stm32f407.cmake
index f91a2f6..6ae9937 100644
--- a/platform/stm32f407.cmake
+++ b/platform/stm32f407.cmake
@@ -3,11 +3,12 @@ set(MCU_DEFINE "STM32F407G")
 
 set(LINKER_SCRIPT ${CMAKE_SOURCE_DIR}/src/hal/stm32f407/linker_script.ld)
 
-set(CMAKE_C_FLAGS "-mcpu=${MCU_SPEC} -DSTM32F407xx -mthumb -mfloat-abi=hard -mfpu=fpv4-sp-d16 -g -O0 ")
-set(CMAKE_CXX_FLAGS "-mcpu=${MCU_SPEC} -DSTM32F407xx -mthumb -mfloat-abi=hard -mfpu=fpv4-sp-d16 -g -std=c++11 -fno-exceptions -fno-rtti -O0")
-set(CMAKE_EXE_LINKER_FLAGS "-T${LINKER_SCRIPT} -mcpu=${MCU_SPEC} --specs=nano.specs -Wl,--gc-sections -O0")
+set(CMAKE_C_FLAGS "-mcpu=${MCU_SPEC} -DSTM32F407xx -mthumb -mfloat-abi=hard -mfpu=fpv4-sp-d16 -g -Os -Wno-write-strings -fno-builtin -fno-lto")
+set(CMAKE_CXX_FLAGS "-mcpu=${MCU_SPEC} -DSTM32F407xx -mthumb -mfloat-abi=hard -mfpu=fpv4-sp-d16 -g -std=c++11 -fno-exceptions -fno-rtti -Os -Wno-write-strings -Wno-endif-labels -fno-builtin -fno-lto")
+set(CMAKE_EXE_LINKER_FLAGS "-T${LINKER_SCRIPT} -mcpu=${MCU_SPEC} --specs=nano.specs -Wl,--gc-sections -Os")
 set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fmessage-length=0 -fno-common -ffunction-sections -fdata-sections")
 
+
 include_directories(
     cmsis/Device/ST/STM32F4/Include
     cmsis/CMSIS/Core/Include
diff --git a/read_uart.py b/read_uart.py
index 0fbc645..0d736dc 100644
--- a/read_uart.py
+++ b/read_uart.py
@@ -1,4 +1,5 @@
 import serial
+import time
 
 port = '/dev/ttyUSB0'  
 baudrate = 115200 
@@ -6,15 +7,21 @@ baudrate = 115200
 ser = serial.Serial(port, baudrate)
 
 output_file = open('serial_data.txt', 'w')
+count = 0
+last_time = 0
 while True:
     try:
         try:
             while True:
                 data = ser.readline().decode('utf-8').strip()  
-                
-                #output_file.write(data + '\n')  
-                
                 print(data)
+                count += 1
+                if (last_time + 1< time.time()):
+                    print("nbr of messages per second: %d" % count)
+                    last_time = time.time()
+                    count = 0
+
+                
                 
         except KeyboardInterrupt:
             ser.close()
diff --git a/src/communication/SPI.h b/src/communication/SPI.h
new file mode 100644
index 0000000..4a4c352
--- /dev/null
+++ b/src/communication/SPI.h
@@ -0,0 +1,41 @@
+#ifndef SPI
+#define SPI
+#include <cstddef>
+#include <cstdint>
+#include <stdint.h> 
+
+enum SPI_state{
+  Read,
+  Write,
+  Done
+};
+
+enum SPI_target {
+  Accelerometer,
+  Magnetometer
+};
+
+struct SPI_information {
+  SPI_state state;
+  size_t size;
+  uint8_t * rx_buffer;
+  uint8_t * tx_buffer;
+  SPI_target target;
+  uint8_t adress;
+};
+
+// use spi for communication
+uint8_t SPI_handle(SPI_information * info);
+void SPI_send_next();
+void SPI_init();
+void CS_A_L();
+void CS_A_H();
+void CS_M_L();
+void CS_M_H();
+uint8_t LSM9DS1_A_read_register_dma(uint8_t reg, uint8_t * dma_rx_buffer, uint8_t * dma_tx_buffer, size_t size);
+uint8_t LSM9DS1_A_write_register_dma(uint8_t reg, uint8_t * dma_rx_buffer, uint8_t * dma_tx_buffer);
+uint8_t LSM9DS1_M_read_register_dma(uint8_t reg, uint8_t * dma_rx_buffer, uint8_t * dma_tx_buffer, size_t size);
+uint8_t LSM9DS1_M_write_register_dma(uint8_t reg, uint8_t * dma_rx_buffer, uint8_t * dma_tx_buffer);
+volatile void SPI_thread();
+
+#endif 
diff --git a/src/communication/i2c.h b/src/communication/i2c.h
index c66652e..e69de29 100644
--- a/src/communication/i2c.h
+++ b/src/communication/i2c.h
@@ -1,18 +0,0 @@
-#ifndef __i2c_imu
-#define __i2c_imu
-#include <stdint.h>
-
-// PB11 is SDA
-// PB10 is SCL
-// this uses i2c2
-
-void configure_i2c();
-void start_i2c_communication();
-//returns 0 if ack, 1 if nack
-void i2c_send_adress(uint8_t adress);
-void i2c_send_data(uint8_t data);
-void i2c_stop();
-void i2c_send_data_multiple(uint8_t * data, uint32_t size);
-uint8_t * i2c_recieve_data(uint8_t adress, uint32_t size);
-
-#endif
diff --git a/src/communication/usart.h b/src/communication/usart.h
index bc488d3..805787c 100644
--- a/src/communication/usart.h
+++ b/src/communication/usart.h
@@ -1,12 +1,30 @@
 #ifndef USART
 #define USART
-    void clock_init_usart1();
-    void enable_usart();
-//void usart_write(USART_TypeDef *usart, char c);
-
-    // actual print fucntions
-    void os_putchar(char c);
-    void os_putstr(const char * s);
-    void os_putint(int i);
-    void os_printf(const char* format, ... );
+#include <stddef.h>
+#include <stdint.h>
+#include "../krnl/scheduler.h"
+
+typedef struct msg_object {
+    struct msg_object * next;
+    char * msg;
+    size_t size;
+} msg_object;
+
+void clock_init_usart1();
+void enable_usart();
+
+// actual print fucntions
+//void os_putchar(char c);
+#ifdef __cplusplus
+void os_putstr(char *s);
+void os_putstr(char *s, size_t size);
+void os_putint(int i);
+void os_putf(float num);
+void os_printf(char * format, ...);
+#endif
+
+// used for actual printing
+int msg_put(char *msg, size_t size);
+
+
 #endif
diff --git a/src/globals.cpp b/src/globals.cpp
index f52a149..f1ffc3a 100644
--- a/src/globals.cpp
+++ b/src/globals.cpp
@@ -4,7 +4,9 @@
 #include "hal/hw_specific.h"
 void OS_WARN (char * msg) {
     //os_interrupt_disable();
-    os_printf("WARNING: %s \n", msg);
+    os_putstr("WARNING: ", 9);
+    os_putstr(msg);
+    os_putstr("\n", 1);
     //os_interrupt_enable();
 }
 
@@ -12,8 +14,8 @@ uint8_t forced_restard = 0;
 void OS_PANIC (char* msg) {
     os_interrupt_disable();
     scheduler_disable();
-    os_printf("PANIC (hard error): %s \n", msg); 
-    os_printf("Calling reset_handler! \n");
+    //os_printf("PANIC (hard error): %s \n", msg); 
+    //os_printf("Calling reset_handler! \n");
     forced_restard = 1;
     void (*reset_handler)(void) = (void (*)(void))(*((uint32_t*)0x00000004));
     reset_handler();
diff --git a/src/globals.h b/src/globals.h
index 4be2805..fa98aef 100644
--- a/src/globals.h
+++ b/src/globals.h
@@ -1,14 +1,14 @@
 #pragma once
 #include <stdint.h>
 
-typedef uint64_t time_t;
+typedef uint64_t os_time_t;
 
 // os defines
 #define OS_MAX_THREAD_COUNT   8
 #define OS_STD_STACK_SIZE     200 
 #define STD_THREAD_PRIORITY   10
 #define STD_THREAD_NAME       "Unnamed thread"
-#define OS_ALLOC_HEAP_SIZE    1024 * 20
+#define OS_ALLOC_HEAP_SIZE    1024 * 40
 
 
 #define MILLISECONDS 1
diff --git a/src/hal/hw_specific.h b/src/hal/hw_specific.h
index 9571b65..a5ee0b3 100644
--- a/src/hal/hw_specific.h
+++ b/src/hal/hw_specific.h
@@ -6,7 +6,7 @@
 void os_interrupt_enable();
 void os_interrupt_disable();
 void miscellaneous_init();
-void idle_thread();
+volatile void idle_thread();
 void print_welcome_msg();
 
 #endif
diff --git a/src/hal/stm32f407/SPI.cpp b/src/hal/stm32f407/SPI.cpp
new file mode 100644
index 0000000..b45f60c
--- /dev/null
+++ b/src/hal/stm32f407/SPI.cpp
@@ -0,0 +1,297 @@
+#include "../../communication/SPI.h"
+
+#include <cstdint>
+#include <stdint.h>
+#include "../../hw_init.h"
+#include "../../krnl/thread.h"
+#include "../../hal/hw_specific.h"
+#include "stm32f407xx.h"
+
+#define SPI_QUEUE_LENGTH 20
+SPI_information * queue[SPI_QUEUE_LENGTH] = {};
+SPI_information * current = 0;
+uint16_t queue_head = 0;
+SPI_information * empty;
+uint8_t dma_done = 1;
+uint8_t enqueue(SPI_information *info) {
+  for (int i = queue_head; i < SPI_QUEUE_LENGTH + queue_head; ++i) {
+    if (i < SPI_QUEUE_LENGTH) {
+      if (queue[i]->size == 0) {
+        queue[i] = info;
+        return 1;
+      }
+    } else {
+      if (queue[i - SPI_QUEUE_LENGTH]->size == 0) {
+        queue[i - SPI_QUEUE_LENGTH] = info;
+        return 1;
+      }
+    }
+  }
+  return 0;
+}
+
+SPI_information *dequeue() {
+  if (queue[queue_head]->size != 0) {
+    SPI_information *ret = queue[queue_head];
+    queue[queue_head] = empty;
+    if (queue_head < SPI_QUEUE_LENGTH - 1) {
+      queue_head++;
+    } else {
+      queue_head = 0;
+    }
+    return ret;
+  } else
+    return nullptr;
+}
+
+#pragma GCC push_options
+#pragma GCC optimize ("O0")
+void SPI_send_next() {
+    if (queue[queue_head]->size != 0) {
+      if (current->state == Done) {
+	   current = dequeue();
+
+	   if (current->state == Done) {
+	     current = empty;
+	     return;
+	   }
+	   if (current->state == Read) {
+	     if (current->target == Accelerometer)
+	       LSM9DS1_A_read_register_dma(current->adress, current->rx_buffer,
+					   current->tx_buffer, current->size);
+	     if (current->target == Magnetometer)
+	       LSM9DS1_M_read_register_dma(current->adress, current->rx_buffer,
+					   current->tx_buffer, current->size);
+	   } else {
+	     if (current->target == Accelerometer)
+	       LSM9DS1_A_write_register_dma(current->adress, current->rx_buffer,
+					    current->tx_buffer);
+	     if (current->target == Magnetometer)
+	       LSM9DS1_M_write_register_dma(current->adress, current->rx_buffer,
+					    current->tx_buffer);
+	   }
+      }
+    } else {
+	if (current->state == Done) {
+	    current = empty;
+	    return;
+	}
+    }
+}
+#pragma GCC pop_options
+
+volatile void SPI_thread() {
+    while (1) {
+      os_interrupt_disable();
+      volatile uint32_t state = DMA2->LISR;
+      volatile uint32_t state2 = DMA2->HISR;
+      if (dma_done)
+	SPI_send_next();
+      os_interrupt_enable();
+      yield();
+    }
+}
+
+// SPI
+uint8_t SPI_handle(SPI_information *info) {
+  return enqueue(info);
+}
+
+void CS_A_H() {
+    GPIOA->BSRR = GPIO_BSRR_BS_4;
+}
+
+void CS_A_L() {
+    GPIOA->BSRR = GPIO_BSRR_BR_4;
+}
+
+
+void CS_M_H() {
+    GPIOA->BSRR = GPIO_BSRR_BS_1;
+}
+
+void CS_M_L() {
+    GPIOA->BSRR = GPIO_BSRR_BR_1;
+}
+
+void DMA2_init() {
+    RCC->AHB1ENR |= RCC_AHB1ENR_DMA2EN;
+
+    // tx
+    DMA2_Stream3->CR = 0;
+    DMA2_Stream3->PAR = (uint32_t) &SPI1->DR;
+    DMA2_Stream3->CR |= (0b011 << DMA_SxCR_CHSEL_Pos);
+    DMA2_Stream3->CR |= (1 << DMA_SxCR_MINC_Pos);
+    DMA2_Stream3->CR |= (0b01 << DMA_SxCR_DIR_Pos);
+    DMA2_Stream3->CR |= (1 << DMA_SxCR_TCIE_Pos);
+    DMA2_Stream3->CR |= (1 << DMA_SxCR_PL_Pos);
+
+    //rx 
+    DMA2_Stream0->CR = 0;
+    DMA2_Stream0->PAR = (uint32_t) &SPI1->DR;
+    DMA2_Stream0->CR |= (0b11 << DMA_SxCR_CHSEL_Pos);
+    DMA2_Stream0->CR |= (1 << DMA_SxCR_MINC_Pos);
+    DMA2_Stream0->CR &= ~(0b011 << DMA_SxCR_DIR_Pos);
+    DMA2_Stream0->CR |= (1 << DMA_SxCR_TCIE_Pos);
+    DMA2_Stream0->CR |= (1 << DMA_SxCR_PL_Pos);
+    DMA2_Stream0->FCR |= DMA_SxFCR_DMDIS;
+
+    //NVIC_EnableIRQ(DMA2_Stream3_IRQn);
+    NVIC_EnableIRQ(DMA2_Stream0_IRQn);
+    //NVIC_SetPriority(DMA2_Stream3_IRQn, 11);
+    NVIC_SetPriority(DMA2_Stream0_IRQn, 10);
+}
+
+static SPI_information dmy = {
+    .state = Done,
+    .size = 0,
+    .rx_buffer = nullptr,
+    .tx_buffer = nullptr,
+    .target = Accelerometer,
+    .adress = 0
+};
+
+void SPI_init() {
+    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN; 
+    RCC->APB2ENR |= RCC_APB2ENR_SPI1EN; 
+
+    GPIOA->MODER |= 0b01 << (4 * 2); // general purpose output 
+    GPIOA->MODER |= 0b01 << (1 * 2); // general purpose output 
+    CS_A_H();
+    CS_M_H();
+    SPI1->CR1 &= ~SPI_CR1_SPE;  
+    
+    GPIOA->MODER |= (2 << (5 * 2)) | (2 << (6 * 2)) | (2 << (7 * 2)); // af mode
+    GPIOA->OSPEEDR |= (3 << (5 * 2)) | (3 << (6 * 2)) | (3 << (7 * 2)); // High speed
+    GPIOA->AFR[0]  |= (5 << (5 * 4)) | (5 << (6 * 4)) | (5 << (7 * 4)); // af 5
+    SPI1->CR1 = 0;
+
+    SPI1->CR1 = SPI_CR1_MSTR     // Master 
+              | SPI_CR1_SSM      // Software CS management
+              | SPI_CR1_SSI      // Set nss high
+              | (3 << 3);    // fPCLK/8 
+
+    SPI1->CR1 |= SPI_CR1_SPE;  
+    SPI1->CR2 = SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN; 
+
+    // dummy
+    empty = &dmy;
+    current = &dmy;
+    queue_head = 0;
+    for (int i = 0; i < SPI_QUEUE_LENGTH; ++i) {
+      queue[i] = &dmy;
+    }
+    
+    DMA2_init();
+}
+
+
+uint8_t LSM9DS1_A_write_register_dma(uint8_t reg, uint8_t * dma_rx_buffer, uint8_t * dma_tx_buffer) {
+    DMA2_Stream3->CR &= ~DMA_SxCR_EN;
+    DMA2_Stream0->CR &= ~DMA_SxCR_EN;
+    uint8_t dma_done = 0;
+
+    dma_tx_buffer[0] = reg & 0x7F;
+    DMA2_Stream3->M0AR = (uint32_t)dma_tx_buffer;
+    DMA2_Stream3->NDTR = 2;
+
+    DMA2_Stream0->M0AR = (uint32_t) dma_rx_buffer;
+    DMA2_Stream0->NDTR = 2;
+
+    CS_A_L();
+    DMA2_Stream3->CR |= DMA_SxCR_EN;
+    DMA2_Stream0->CR |= DMA_SxCR_EN;
+    return 0;
+}
+
+uint8_t LSM9DS1_A_read_register_dma(uint8_t reg, uint8_t * dma_rx_buffer, uint8_t * dma_tx_buffer, size_t size) {
+    DMA2_Stream3->CR &= ~DMA_SxCR_EN;
+    DMA2_Stream0->CR &= ~DMA_SxCR_EN;
+    uint8_t dma_done = 0;
+
+    dma_tx_buffer[0] = reg | 0x80;
+    for (int i = 1; i < size; ++i)
+      dma_tx_buffer[i] = 0x00;
+    DMA2_Stream3->M0AR = (uint32_t) dma_tx_buffer;
+    DMA2_Stream3->NDTR = size;
+
+    DMA2_Stream0->M0AR = (uint32_t) dma_rx_buffer;
+    DMA2_Stream0->NDTR = size;
+
+    CS_A_L();
+    DMA2_Stream3->CR |= DMA_SxCR_EN;
+    DMA2_Stream0->CR |= DMA_SxCR_EN;
+    return 0;
+}
+
+uint8_t LSM9DS1_M_read_register_dma(uint8_t reg, uint8_t *dma_rx_buffer,
+                                    uint8_t *dma_tx_buffer, size_t size) {
+    DMA2_Stream3->CR &= ~DMA_SxCR_EN;
+    DMA2_Stream0->CR &= ~DMA_SxCR_EN;
+    uint8_t dma_done = 0;
+
+    dma_tx_buffer[0] = reg | 0x80;
+    if (size > 2)
+      dma_tx_buffer[0] |= (1 << 6);
+    for (int i = 1; i < size; ++i)
+      dma_tx_buffer[i] = 0x00;
+    DMA2_Stream3->M0AR = (uint32_t)dma_tx_buffer;
+    DMA2_Stream3->NDTR = size;
+
+    DMA2_Stream0->M0AR = (uint32_t) dma_rx_buffer;
+    DMA2_Stream0->NDTR = size;
+
+    CS_M_L();
+    DMA2_Stream3->CR |= DMA_SxCR_EN;
+    DMA2_Stream0->CR |= DMA_SxCR_EN;
+    return 0;
+}
+
+uint8_t LSM9DS1_M_write_register_dma(uint8_t reg, uint8_t * dma_rx_buffer, uint8_t * dma_tx_buffer) {
+    DMA2_Stream3->CR &= ~DMA_SxCR_EN;
+    DMA2_Stream0->CR &= ~DMA_SxCR_EN;
+    uint8_t dma_done = 0;
+
+    dma_tx_buffer[0] = reg & 0x7F;
+    DMA2_Stream3->M0AR = (uint32_t)dma_tx_buffer;
+    DMA2_Stream3->NDTR = 2;
+
+    DMA2_Stream0->M0AR = (uint32_t) dma_rx_buffer;
+    DMA2_Stream0->NDTR = 2;
+
+    CS_M_L();
+    DMA2_Stream3->CR |= DMA_SxCR_EN;
+    DMA2_Stream0->CR |= DMA_SxCR_EN;
+    return 0;
+}
+
+extern "C" {
+    void dma2_stream3_handler(){
+	if (DMA2->LISR & DMA_LISR_TCIF3) {
+	    DMA2->LIFCR |= DMA_LIFCR_CTCIF3;
+	}
+	if (DMA2->LISR & DMA_LISR_HTIF3) {
+	    DMA2->LIFCR |= DMA_LIFCR_CHTIF3;
+	}
+    }
+
+    void dma2_stream0_handler() {
+      volatile uint32_t state = DMA2->LISR;
+	if (DMA2->LISR & DMA_LISR_TCIF0) {
+	    DMA2->LIFCR |= DMA_LIFCR_CTCIF3;
+	    DMA2->LIFCR |= DMA_LIFCR_CHTIF3;
+	    DMA2->LIFCR |= DMA_LIFCR_CTCIF0;
+	    DMA2->LIFCR |= DMA_LIFCR_CHTIF0;
+	    DMA2_Stream3->CR &= ~DMA_SxCR_EN;
+	    DMA2_Stream0->CR &= ~DMA_SxCR_EN;
+	    CS_A_H();
+	    CS_M_H();
+	    current->state = Done;
+	    current = empty;
+	    //os_printf("res: %d \n", current->rx_buffer[1]);
+	    dma_done = 1;
+            SPI_send_next();
+            }
+    }
+}
+
diff --git a/src/hal/stm32f407/hw_init.cpp b/src/hal/stm32f407/hw_init.cpp
index 2a99a2b..9a8505c 100644
--- a/src/hal/stm32f407/hw_init.cpp
+++ b/src/hal/stm32f407/hw_init.cpp
@@ -47,7 +47,8 @@ void interrupt_init() {
     
     // set pendsv prio to 0xff and systick to 0x00
     SCB->SHP[10] = 0xff;
-    SCB->SHP[11] = 0x00;
+    SCB->SHP[11] = 0x05;
+    //NVIC_SetPriority(DMA1_Stream6_IRQn, 3);
     // enable systick and pendsv
     SysTick->CTRL |= (1 << 0); // enable  
     // enable global interrupts
diff --git a/src/hal/stm32f407/hw_specific.cpp b/src/hal/stm32f407/hw_specific.cpp
index b093550..07f8407 100644
--- a/src/hal/stm32f407/hw_specific.cpp
+++ b/src/hal/stm32f407/hw_specific.cpp
@@ -1,8 +1,17 @@
 #include "../hw_specific.h"
 #include "../../globals.h"
 #include "../../communication/usart.h"
+#include "stm32f407xx.h"
 #include <stm32f4xx.h>
 
+void os_interrupt_enable() {
+    __asm volatile ("CPSIE         I \n");
+}
+
+void os_interrupt_disable() {
+    __asm volatile ("CPSID         I \n");
+}
+
 extern "C" {
   __attribute__((naked)) void pendsv_handler(void) {
 
@@ -41,9 +50,18 @@ extern "C" {
     if (!sched_on) return;
     SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   }
+
+  volatile uint32_t tim2_overflow = 0;
+
+  void tim2_handler(void) {
+    if (TIM2->SR & TIM_SR_UIF) {
+      TIM2->SR &= ~TIM_SR_UIF;
+      tim2_overflow++;
+    }
+  }
 }
 
-void idle_thread () {
+volatile void idle_thread () {
   uint64_t cnt = 0;
   while (1) {
     cnt++; 
@@ -52,7 +70,7 @@ void idle_thread () {
   }
 }
 
-void one_second_thread () {
+volatile void one_second_thread () {
   uint64_t cnt = 0;
   while (1) {
       GPIOD->ODR ^= (1 << 15); // Toggle Blue LED
@@ -60,6 +78,26 @@ void one_second_thread () {
   }
 }
 
+void TIM2_init() {
+    RCC->APB1ENR |=  (1 << 0); // turn on clock form timer
+    TIM2->PSC = 83;
+    TIM2->ARR = 0xFFFFFFFF; // max
+    TIM2->DIER |= TIM_DIER_UIE;
+    TIM2->CR1 |= (1 << 0); // enable
+}
+
+uint64_t now_high_accuracy() {
+    uint64_t high, low;
+
+    // Double-read for atomicity
+    do {
+        high = tim2_overflow;
+        low = TIM2->CNT;
+    } while (high != tim2_overflow);
+
+    return high * 4294967295 + low;
+}
+
 void miscellaneous_init() {
     FPU->FPCCR |= (1 << 30) | (1 << 31);  // Set ASPEN and LSPEN
     SCB->CPACR |= (0xF << 20); 
@@ -75,14 +113,19 @@ void miscellaneous_init() {
           (0b11 << (15 * 2))); // Clear mode bits
     GPIOD->MODER |= ((0b01 << (12 * 2)) | (0b01 << (13 * 2)) |
                      (0b01 << (14 * 2)) | (0b01 << (15 * 2)));
-    
+   
+    RCC->AHB1ENR |= (1 << 21); // enable DMA1 clock
+    NVIC_EnableIRQ(DMA1_Stream6_IRQn);
+    NVIC_EnableIRQ(TIM2_IRQn);
     register_thread_auto(&one_second_thread, 128, STD_THREAD_PRIORITY, "1_second_thread");
+    TIM2_init();
 }
 
+
 void print_welcome_msg() {
-    os_printf("\n\n|-----------------------------------------| \n");
-    os_printf("System initialisation done. \n");
-    os_printf("Simple Realtime Operating System 0.2 \n");
-    os_printf("Compiled for STM32f407G \n");
-    os_printf("\n");
+    os_putstr("\n\n|-----------------------------------------| \n");
+    os_putstr("System initialisation done. \n");
+    os_putstr("Simple Realtime Operating System 0.2 \n");
+    os_putstr("Compiled for STM32f407G \n");
+    os_putstr("\n");
 }
diff --git a/src/hal/stm32f407/i2c.cpp b/src/hal/stm32f407/i2c.cpp
index e9b4130..e69de29 100644
--- a/src/hal/stm32f407/i2c.cpp
+++ b/src/hal/stm32f407/i2c.cpp
@@ -1,157 +0,0 @@
-#include "../../communication/i2c.h"
-#include <cstdint>
-#include <stm32f4xx.h>
-#include <stdint.h>
-#include "../../krnl/mem.h"
-#include "../../krnl/scheduler.h"
-#include "../../communication/usart.h"
-
-void configure_i2c() {
-    I2C1->CR1 &= ~(1 << 0); // disable i2c for config 
-
-    // reset i2c1
-    I2C1->CR1 |= (1 << 15);
-    I2C1->CR1 &= ~(1 << 15);
-    
-    // gpio config and so on
-    RCC->APB2ENR |= (1 << 3); // enable IOPBEN
-    
-    // clock config for I2C1
-    // I2C1 is on the APB1 clock.
-    RCC->APB1ENR |= (1 << 21); // enable clock for i2c1;
-    RCC->AHB1ENR |= (1 << 1); // enable clock for GPIOB;
-
-    GPIOB->AFR[0] |= (4 << (4 * 6)); // Set AF4 
-    GPIOB->AFR[0] |= (4 << (4 * 7)); // Set AF4 
-    GPIOB->OTYPER |= (1 << 6) | (1 << 7); // open-drain for I2C
-    GPIOB->PUPDR &= ~((0b11 << 12) | (0b11 << 14)); // clea for PB6, PB7
-    GPIOB->PUPDR |= (0b01 << 12) | (0b01 << 14);    // Set pull-up mode
-
-    GPIOB->MODER &= ~(0b11 << 12);  // Clear MODE6
-    GPIOB->MODER |= (0b10 << 12);   // Set MODE6 to Alternate function open drain
-    GPIOB->MODER &= ~(0b11 << 14); // Clear MODE7
-    GPIOB->MODER |= (0b10 << 14);  // Set MODE7 to Alternate function open drain
-
-    I2C1->CR1 |= (1 << 15); // reset i2c befor config 
-    I2C1->CR1 &= ~(1 << 15); // clear reset i2c 
-
-    // speed is 42 MHz so 0b101010
-    uint32_t speed = 0b101010;
-    I2C1->CR2 = (I2C1->CR2 & ~I2C_CR2_FREQ_Msk) | (speed & I2C_CR2_FREQ_Msk); // write bit field
-
-    // configure the i2c1 ccr
-    I2C1->CCR &= ~(1 << 15); // set standard mode
-    // target is 100kHz SCL, so 10 µs
-    // pclk is 42 MHz, so T_pclk is 23,81 ns.
-    // T_SCL = T_pclk * CCR
-    // -> CCR = T_SCL / T_pclk = 10 µs / 23,81 ns = 420
-    speed = 420;
-    I2C1->CCR = (I2C1->CCR & ~I2C_CCR_CCR_Msk) | (speed & I2C_CCR_CCR_Msk);
-
-    // configure the i2c Trise
-    // time should be 1000 ns / T_pclk + 1 = 40; 
-    speed = 40;
-    //I2C1->TRISE = (I2C1->TRISE & ~I2C_TRISE_TRISE_Msk) | (speed & I2C_TRISE_TRISE_Msk);
-
-    // program the I2C_CR1 register to enable the peripheral
-    I2C1->CR1 &= ~(1 << 1); // i2c mode
-    I2C1->CR1 |= (1 << 0); // i2c enable 
-}
-
-void i2c_recover() {
-    I2C1->CR1 &= ~(1 << 0); // disable I2C1
-
-    // Configure SCL and SDA as GPIO open-drain with pull-up
-    GPIOB->MODER &= ~((0b11 << 12) | (0b11 << 14));  // Clear MODER6, MODER7
-    GPIOB->MODER |= (0b01 << 12) | (0b01 << 14);     // Set to General-Purpose Output mode
-    GPIOB->OTYPER |= (1 << 6) | (1 << 7);           // Open-drain
-    GPIOB->PUPDR &= ~((0b11 << 12) | (0b11 << 14)); // Clear pull-ups
-    GPIOB->PUPDR |= (0b01 << 12) | (0b01 << 14);    // Enable pull-ups
-    
-    for (int i = 0; i < 18; ++i)  {
-        for (volatile int delay = 0; delay < 1000; delay++);
-        GPIOB->ODR ^= (1 << 6);
-    }
-
-    // Generate a STOP condition manually
-    GPIOB->ODR &= ~(1 << 7); // SDA low
-    for (volatile int delay = 0; delay < 1000; delay++);
-    GPIOB->ODR |= (1 << 6);  // SCL high
-    for (volatile int delay = 0; delay < 1000; delay++);
-    GPIOB->ODR |= (1 << 7);  // SDA high (STOP condition)
-    for (volatile int delay = 0; delay < 1000; delay++);
-
-    // Restore alternate function mode for I2C operation
-    GPIOB->MODER &= ~((0b11 << 12) | (0b11 << 14)); 
-    GPIOB->MODER |= (0b10 << 12) | (0b10 << 14);   // Set to Alternate Function
-
-    I2C1->CR1 |= (1 << 0); // Enable I2C1
-}
-
-void start_i2c_communication() {
-    //if (I2C1->SR2 & (1 << 1)) { // Bus is busy, need to reset the i2c device
-    //    i2c_recover(); // this causes more issues that it solves
-    //    configure_i2c();
-    //}
-    I2C1->CR1 |= (1 << 8); // generate start condition
-    uint64_t time = now();
-    while (!(I2C1->SR1 & (1<<0))) {
-    } // wait for start condition generated
-}
-
-void i2c_send_adress(uint8_t adress) {
-    I2C1->DR = adress;
-    while (!(I2C1->SR1 & (1<<1))); // wait for adress bit to set 
-    uint8_t temp = I2C1->SR1 | I2C1->SR2;  // read SR1 and SR2 to clear the ADDR bit
-}
-
-void i2c_stop() {
-    I2C1->CR1 |= (1<<9); // stop bit
-    while(!( I2C1->CR1 & (1<<9))) ;
-}
-
-void i2c_send_data(uint8_t data) {
-    while (!(I2C1->SR1 & (1<<7))); // wait for tx to finish 
-    I2C1->DR = data;
-    while (!(I2C1->SR1 & (1<<2))); // wait for transfer to finish
-}
-
-void i2c_send_data_multiple(uint8_t * data, uint32_t size) {
-    for (int i = 0; i < size; ++i) {
-        while (!(I2C1->SR1 & (1<<7))); // wait for tx to finish 
-        I2C1->DR = data[i];
-    }
-    while (!(I2C1->SR1 & (1<<2))); // wait for transfer to finish
-
-    I2C1->CR1 |= (1<<9); // stop bit
-}
-
-uint8_t * i2c_recieve_data(uint8_t adress, uint32_t size) {
-    uint8_t * buffer = (uint8_t *)os_alloc(size);
-    if (!buffer) {
-        OS_WARN("Cannot allocate ");
-        return NULL;
-    }
-
-    I2C1->DR = adress; // Send address
-    while (!(I2C1->SR1 & (1 << 1))); // Wait for ADDR
-    uint8_t dummy = I2C1->SR1 | I2C1->SR2; // Clear ADDR
-
-    if (size == 1) {
-        I2C1->CR1 &= ~(1 << 10); // Disable ACK
-        I2C1->CR1 |= (1 << 9); // Generate STOP
-        while (!(I2C1->SR1 & (1 << 6))); // Wait for RxNE
-        buffer[0] = I2C1->DR; // Read data
-    } else {
-        I2C1->CR1 |= (1 << 10); // Enable ACK
-        for (uint32_t i = 0; i < size; i++) {
-            while (!(I2C1->SR1 & (1 << 6))); // Wait for RxNE
-            buffer[i] = I2C1->DR; // Read data
-
-            if (i == size - 2) I2C1->CR1 &= ~(1 << 10); // Disable ACK before last byte
-            else if (i == size - 1) I2C1->CR1 |= (1 << 9); // Generate STOP
-        }
-    }
-
-    return buffer;
-}
diff --git a/src/hal/stm32f407/startup.c b/src/hal/stm32f407/startup.c
index ce027d6..0a86aef 100644
--- a/src/hal/stm32f407/startup.c
+++ b/src/hal/stm32f407/startup.c
@@ -75,6 +75,7 @@ void spi5_handler(void) __attribute__((weak, alias("default_handler")));
 void i2c4_ev_handler(void) __attribute__((weak, alias("default_handler")));
 void i2c4_er_handler(void) __attribute__((weak, alias("default_handler")));
 void lptim1_exti23_handler(void) __attribute__((weak, alias("default_handler")));
+void tim2_handler(void) __attribute__((weak, alias("default_handler")));
 
 uint32_t isr_vector[ISR_VECTOR_SIZE_WORDS] __attribute__((section(".isr_vector"))) = {
   STACK_POINTER_INIT_ADDRESS,
@@ -123,7 +124,7 @@ uint32_t isr_vector[ISR_VECTOR_SIZE_WORDS] __attribute__((section(".isr_vector")
   (uint32_t)&tim1_up_handler,
   (uint32_t)&tim1_trg_com_tim11_handler,
   (uint32_t)&tim1_cc_handler,
-  0,
+  (uint32_t)&tim2_handler,
   0,
   0,
   (uint32_t)&i2c1_ev_handler,
diff --git a/src/hal/stm32f407/usart.cpp b/src/hal/stm32f407/usart.cpp
index f88396b..0344253 100644
--- a/src/hal/stm32f407/usart.cpp
+++ b/src/hal/stm32f407/usart.cpp
@@ -1,13 +1,15 @@
+#include <cstddef>
 #include <cstdint>
 #include <stdint.h>
 #include <stm32f4xx.h>
 #include <stdio.h>
 #include <stdarg.h>
+#include "../../communication/usart.h"
 #include "../../krnl/mem.h"
 
 // ill use usart 2 / pa2 tx, pa3 rx
 void enable_usart(){
-    // enable usart2 clock
+// enable usart2 clock
     RCC->APB1ENR |= (1 << 17);
     // enable gpioa clock
     RCC->AHB1ENR |= (1 << 0);
@@ -32,24 +34,35 @@ void enable_usart(){
     USART2->CR1 &= ~(1 << 10);
     //115200 Baud
     // sysclk is 168, apb1 prescaler is 4, so usart clock should be 42mhz, so BRR = usart_clk / 115200 = 364,6
+
     USART2->BRR = 364; 
+    USART2->BRR |= (22 << 4);
+    USART2->BRR |= 13;
     USART2->CR1 |= (1 << 13);
     USART2->CR1 |= (1 << 2) | (1 << 3);
-    
-
 }
 
 
+
+
+
+#define MSG_BUFFER_SIZE 128
+
 void os_putchar(char c) {
     USART2->DR = c;
     while (!(USART2->SR & USART_SR_TC));
 }
 
-void os_putstr(const char *s) {
-	while (*s != '\000') {
-		os_putchar(*s);
-		s++;
+void os_putstr(char *s) {
+    size_t size = 0;
+	while (s[size] != '\000') {
+		size++;
 	}
+    msg_put(s, size);
+}
+
+void os_putstr(char *s, size_t size) {
+    msg_put(s, size);
 }
 
 int get_int_size (int i) {
@@ -64,46 +77,67 @@ int get_int_size (int i) {
     return 0;
 }
 
+char  result[16];
 void os_putint(int num) {
+    //char * result = (char*) os_alloc(sizeof(char) * 16);
     if (num == 0) {
-        os_putchar('0');
+        os_putstr("0", 1);
         return;
     }
-    int is_negative = 0;
-    int i = 0;
-    int size = get_int_size(num);
-    if (num < 0) {
-        is_negative = 1;
-        num = - num;
-    }
-    
-    char* result = (char *) os_alloc(size + is_negative + 1);
-    int it = 0;
-    while (num > 0 && it < 1000) {
-        it++;
-        result[i++] = (num % 10) + '0';
-        num /= 10;
-    }
+    char *ptr = result + 15; 
+    char *start = ptr;
 
-    if (is_negative == 1) {
-        result[i++] = '-';
-        size++;
+    int is_negative = (num < 0);
+    if (is_negative) {
+        num = -num;
     }
 
-    for (int j = 0; j < i / 2; j++) {
-        char temp = result[j];
-        result[j] = result[i - j - 1];
-        result[i - j - 1] = temp;
+    while (num > 0) {
+        *--ptr = (num % 10) + '0';
+        num /= 10;
     }
-    for (int i = 0; i < size; ++i) {
-        os_putchar(result[i]);
+    if (is_negative) {
+        *--ptr = '-';
     }
+    uint32_t len = start - ptr;
+    os_putstr(ptr, len);
+}
+
+void os_putf(float num) {
+          int i_part = num;
+	  if (num < 0) {
+	    i_part = -i_part;
+	    os_putchar('-');
+	    num *= -1;
+	  }
 
-    os_free(result);
+          float f_part = (num - i_part);
+          if (f_part < 0) {
+              f_part *= -1;
+          }
+          os_putint(i_part);
+
+          //f part
+          os_putstr(".", 1);
+
+          int n_of_0 = 0;
+          for (int i = 0; i < 7; ++i) {
+              f_part = f_part * 10;
+              if (f_part > 1) {}
+              else n_of_0++;
+          }
+
+          if (n_of_0 < 7) {
+              for (int i = 0; i < n_of_0; ++i) {
+                  os_putint(0);
+              }
+              os_putint( (int) f_part);
+          }
+          else os_putint(0);
 }
 
-void os_printf(const char* format, ... ) {
-    GPIOD->ODR |= (1 << 12);
+void os_printf(char *format, ...) {
+  GPIOD->ODR |= (1 << 12);
     __disable_irq();
     va_list args;
     va_start(args, format);
@@ -128,36 +162,11 @@ void os_printf(const char* format, ... ) {
 
         case 'f':
           num_f = va_arg(args, double);
-          i_part = num_f;
-          f_part = (num_f - i_part) ;
-          if (f_part < 0) {
-              f_part *= -1;
-              os_putchar('-');
-          }
-          os_putint(i_part);
-
-          //f part
-          os_putchar('.');
-
-          n_of_0 = 0;
-          for (int i = 0; i < 7; ++i) {
-              f_part = f_part * 10;
-              if (f_part > 1) {}
-              else n_of_0++;
-          }
-
-          if (n_of_0 < 7) {
-              for (int i = 0; i < n_of_0; ++i) {
-                  os_putint(0);
-              }
-              os_putint( (int) f_part);
-          }
-          else os_putint(0);
+          os_putf(num_f);
           break;
 
         case 's':
           str = va_arg(args, const char *);
-          os_putstr(str);
           break;
 
         case 'c':
@@ -177,5 +186,14 @@ void os_printf(const char* format, ... ) {
     os_putchar('\0');
     va_end(args);
     GPIOD->ODR &= ~(1 << 12);
-    __enable_irq();
+    __enable_irq();   
+}
+msg_object l = {.next = (msg_object*) nullptr, .msg = (char*) nullptr, .size = 0};
+msg_object * last = &l;
+msg_object * head = &l;
+int msg_put(char *msg, size_t size) {
+    for (int i = 0;i < size; ++i) {
+        os_putchar(msg[i]);
+    }
+    return 1;
 }
diff --git a/src/krnl/mem.cpp b/src/krnl/mem.cpp
index 9796a2f..4ddbf97 100644
--- a/src/krnl/mem.cpp
+++ b/src/krnl/mem.cpp
@@ -1,4 +1,5 @@
 #include "mem.h"
+#include <cstdint>
 #include <stdio.h>
 
 struct Chunk{
@@ -6,6 +7,7 @@ struct Chunk{
     uint8_t free;
 } Chunk;
 
+int mem_full = 0;
 uint8_t heap[OS_ALLOC_HEAP_SIZE] __attribute__((aligned(8)));
 #define LEDGER_SIZE    (OS_ALLOC_HEAP_SIZE + 63) / 64 + 1
 struct Chunk ledger[LEDGER_SIZE];
@@ -41,10 +43,12 @@ void *os_alloc(size_t size) {
                 best_fit_size = current_size;
                 current_size = 0;
             }
+            i += ledger[i].size;
         }
     }
 
     if (best_fit_size == 65535) {
+        mem_full = 1;
         return nullptr;// error return
     }
 
@@ -65,6 +69,7 @@ void *os_alloc(size_t size) {
 }
 
 void os_free(void * pointer) {
+    if (!os_test_mem(pointer)) return;
     int id = ((uint64_t) pointer - (uint64_t)&heap) / 64;
     struct Chunk * cur = &ledger[id];
     int size = cur->size;
@@ -75,3 +80,10 @@ void os_free(void * pointer) {
     }
 }
 
+
+int os_test_mem(void *pointer) {
+    if ( pointer < heap + OS_ALLOC_HEAP_SIZE && pointer >= heap) {
+        return 1;
+    }
+    return 0;
+}
diff --git a/src/krnl/mem.h b/src/krnl/mem.h
index 4ee0551..f90de31 100644
--- a/src/krnl/mem.h
+++ b/src/krnl/mem.h
@@ -4,8 +4,14 @@
 #include <stdio.h>
 #include "../globals.h"
 
+extern int mem_full;
 void mem_init();
 void * os_alloc(size_t size);
 void os_free(void * pointer);
 
+/*
+ * Test weather or not pointer was allocated with os_alloc 
+ */
+int os_test_mem(void * pointer);
+
 #endif
diff --git a/src/krnl/scheduler.cpp b/src/krnl/scheduler.cpp
index 1af4dda..5bfb6fb 100644
--- a/src/krnl/scheduler.cpp
+++ b/src/krnl/scheduler.cpp
@@ -1,5 +1,6 @@
 #include "scheduler.h"
 #include "../communication/usart.h"
+#include "thread.h"
 #include <cstdio>
 
 
@@ -57,7 +58,8 @@ extern "C" {
             return;
         } 
 
-        current_thread->last_time = schedule_counter;
+        current_thread->last_time = now_high_accuracy();
+        volatile os_pcb * next_thread = current_thread;
   
         for (uint16_t i = 0; i < OS_MAX_THREAD_COUNT; ++i){
             uint8_t exists = thread_list[i]->sp != 0;
@@ -69,33 +71,46 @@ extern "C" {
                 uint8_t last_time_was_earlier = thread_list[i]->last_time < current_thread->last_time;
                 uint8_t current_is_sleeping = (current_thread->sleep_until >= now());
                 if ( (is_larger_priority || current_is_sleeping ) && last_time_was_earlier ) {
-                    current_thread = thread_list[i];
+                    next_thread = thread_list[i];
                 }
             }
         }
         ++schedule_counter;
+        current_thread = (os_pcb *) next_thread;
     }
-
 }
 
 uint64_t now() {
   return ticks;
 }
 
+
 void print_thread_info() {
-    os_printf("Thread overview: \n");
+    os_putstr("Thread overview: \n");
     uint8_t cnt = 0;
     for (int i = 0; i < OS_MAX_THREAD_COUNT; ++i) {
         if (thread_list[i]->sp != 0) {
             cnt++;
             os_pcb * cur = thread_list[i];
-            os_printf("Thread:      %s\n", cur->name);
-            os_printf("Priority:    %d\n", (int) cur->priority);
-            os_printf("Last time:   %d\n", (int) cur->last_time);
-            os_printf("Ready:       %d\n", (int) cur->rdy);
-            os_printf("Sleep until: %d\n", (int) cur->sleep_until);
-            os_printf("\n");
+            os_putstr("Thread:      ");
+            os_putstr(cur->name);
+            os_putstr("\n", 1);
+            os_putstr("Priority:    ");
+            os_putint((int) cur->priority);
+            os_putstr("\n", 1);
+            os_putstr("Last time:   ");
+            os_putint((int) cur->last_time);
+            os_putstr("\n", 1);
+            os_putstr("Ready:       ");
+            os_putint((int) cur->rdy);
+            os_putstr("\n");
+            os_putstr("Sleep until: ");
+            os_putint((int) cur->sleep_until);
+            os_putstr("\n");
+            os_putstr("\n");
         }
     }
-    os_printf("In total there are %d threads.\n", cnt);
+    os_putstr("In total there are ");
+    os_putint(cnt);
+    os_putstr(" threads.\n");
 }
diff --git a/src/krnl/scheduler.h b/src/krnl/scheduler.h
index 96f1279..5100761 100644
--- a/src/krnl/scheduler.h
+++ b/src/krnl/scheduler.h
@@ -4,10 +4,13 @@
 #include "../globals.h"
 
 extern uint64_t ticks;
+
+#ifdef __cplusplus
 extern "C" {
     extern os_pcb * volatile current_thread; 
     void schedule();
 }
+#endif
 extern uint8_t sched_on;
 
 void scheduler_init();
@@ -16,6 +19,7 @@ void scheduler_disable();
 int register_thread(os_pcb * thread);
 int remove_thread(os_pcb * thread);
 uint64_t now();
+uint64_t now_high_accuracy(); // µs
 void print_thread_info();
 
 #endif
diff --git a/src/krnl/thread.cpp b/src/krnl/thread.cpp
index 89c038a..4344da0 100644
--- a/src/krnl/thread.cpp
+++ b/src/krnl/thread.cpp
@@ -7,11 +7,11 @@
 
 
 
-os_pcb *register_thread_auto(void (*thread_handler)()) {
+os_pcb *register_thread_auto(volatile void (*thread_handler)()) {
     return register_thread_auto(thread_handler, OS_STD_STACK_SIZE, STD_THREAD_PRIORITY, STD_THREAD_NAME);
 }
 
-os_pcb *register_thread_auto(void (*thread_handler)(), uint32_t stack_size, uint8_t priority, char* name) {
+os_pcb *register_thread_auto(volatile void (*thread_handler)(), uint32_t stack_size, uint8_t priority, char* name) {
     uint32_t *stack = (uint32_t *) os_alloc(stack_size * sizeof(uint32_t));  
     if (stack == nullptr) {
       return 0;
@@ -36,3 +36,8 @@ void sleep(uint64_t time) {
   current_thread->sleep_until = now() + time;
   yield();
 }
+
+void sleep_until(uint64_t time) {
+  current_thread->sleep_until = time;
+  yield();
+}
diff --git a/src/krnl/thread.h b/src/krnl/thread.h
index 7572757..0fee179 100644
--- a/src/krnl/thread.h
+++ b/src/krnl/thread.h
@@ -6,17 +6,17 @@
 
 typedef struct {
   // if this ordering is changed the compiler will later insert ldrd instructions that cause a hard fault
-		void* sp;
-        char* name;
-		time_t last_time;
-		uint8_t priority;
-		uint8_t rdy;
-        uint64_t sleep_until;
+  void *sp;
+  char *name;
+  os_time_t last_time;
+  uint8_t priority;
+  uint8_t rdy;
+  uint64_t sleep_until;
 } os_pcb;
 
-
 void yield();
 void sleep(uint64_t time);
+void sleep_until(uint64_t time);
 
 void os_stack_init(os_pcb * thread, void * thread_handler, void * stack, uint32_t size_of_stack);
 
@@ -24,9 +24,11 @@ void os_stack_init(os_pcb * thread, void * thread_handler, void * stack, uint32_
  * This is the function you want to call if you want to create a thread.
  */
 
-os_pcb *register_thread_auto(void (*thread_handler)());
-os_pcb *register_thread_auto(void (*thread_handler)(), uint32_t stack_size, uint8_t priority, char* name);
+#ifdef __cplusplus
+os_pcb *register_thread_auto(volatile void (*thread_handler)());
+os_pcb *register_thread_auto(volatile void (*thread_handler)(), uint32_t stack_size, uint8_t priority, char* name);
 #define OS_THREAD(handler) register_thread_auto(&handler);
+#endif
 
   
 #endif
diff --git a/src/main.cpp b/src/main.cpp
index a8a8830..edc48c2 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -1,16 +1,17 @@
 #include <cstdint>
 #include <stdint.h>
-#include <stdio.h>
+#include "communication/LSM9DS1.h"
 #include "globals.h"
 #include "hw_init.h"
 #include "krnl/scheduler.h"
 #include "krnl/thread.h"
 #include "krnl/mem.h"
 #include "communication/usart.h"
-#include "communication/usart.h"
-#include "communication/i2c.h"
-#include "communication/LSM9DS1.h"
 #include "hal/hw_specific.h"
+#include "communication/LSM9DS1.h"
+#include "communication/SPI.h"
+#include "attitude/ekf.h"
+#include "attitude/complementary_filter.h"
 
 
 int main (void) {
@@ -27,15 +28,20 @@ int main (void) {
     register_thread_auto(&idle_thread, 200, 0, "idle_thread");
 
     // User Threads are defined here
-    //register_thread_auto(&test_thread, 200, 10, "test_thread");
-    register_thread_auto(&LSM9DS1_thread, 1000, 20, "LSM9DS1_thread");
+    register_thread_auto(&LSM9DS1_thread, 2000, STD_THREAD_PRIORITY, "LSM9DS1_thread");
+    register_thread_auto(&SPI_thread, 500, 10, "SPI_thread");
+    register_thread_auto(&attitude_thread, 3000, STD_THREAD_PRIORITY + 1, "attitude_thread");
+    //register_thread_auto(&attitude_thread_complementary_filter, 3000, STD_THREAD_PRIORITY + 1, "attitude_thread");
     // End of user thread definitions
+    SPI_init();
 
     print_thread_info();
     // start system
     scheduler_enable();
 
 
-    while (1) {
+    //idle_thread();
+    while(1) {
+        //OS_WARN("Scheduler didn't start!");
     }
 }
diff --git a/src/math/matrix.h b/src/math/matrix.h
index 9c5f277..32782a0 100644
--- a/src/math/matrix.h
+++ b/src/math/matrix.h
@@ -9,7 +9,7 @@ class Quaternion;
 template <size_t m, size_t n>
 class Mat {
     protected:
-    double r[m][n]{};
+    float r[m][n]{};
 
     public:
         Mat() {}
@@ -21,7 +21,7 @@ class Mat {
             }
         }
         ~Mat() {}
-        const double *operator[](size_t index) const {
+        const float *operator[](size_t index) const {
             if (m < index) {
                 OS_WARN("Out of Bounds in Mat acces, returning 0 element!");
                 return r[0];
@@ -29,7 +29,7 @@ class Mat {
             return r[index];
         }
 
-        double *operator[](size_t index) {
+        float *operator[](size_t index) {
             if (m < index) {
                 OS_WARN("Out of Bounds in Mat acces, returning 0 element!");
                 return r[0];
@@ -81,7 +81,7 @@ class Mat {
             return result;
         }
 
-        Mat operator*(double scalar) const {
+        Mat operator*(float scalar) const {
             Mat result;
             for (size_t i = 0; i < m; ++i) {
                 for (size_t j = 0; j < n; ++j) {
@@ -91,7 +91,7 @@ class Mat {
             return result;
         }
 
-        Mat operator/(double scalar) const {
+        Mat operator/(float scalar) const {
             if (scalar == 0) {
                 OS_WARN("M err div");
                 return *this;
@@ -116,11 +116,10 @@ class Mat {
             return *this;
         }
 
-        template <size_t p>
-        Vec<p> operator*(const Vec<m> &v) const {
-            Vec<p> result;
+        Vec<m> operator*(const Vec<n> &v) const {
+            Vec<m> result;
             for (size_t i = 0; i < m; ++i) {
-                double sum = 0.0;
+                float sum = 0.0;
                 for (size_t j = 0; j < n; ++j) {
                     sum += r[i][j] * v[j];
                 }
@@ -130,17 +129,17 @@ class Mat {
         }
 
 
-        double det() {
+        float det() {
             if (m != n) {
                 OS_WARN("Error: Determinant of non-square matrix!");
                 return 0;
             }
             if (n == 1) return this->r[0][0];
             Mat<m, n> temp = *this; 
-            double det = 1;
+            float det = 1;
 
             for (int i = 0; i < n; ++i) {
-                double max_elem = temp[i][i];
+                float max_elem = temp[i][i];
                 int max_row = i;
                 for (int k = i + 1; k < n; ++k) {
                     if (fabs(temp[k][i]) > fabs(max_elem)) {
@@ -151,7 +150,7 @@ class Mat {
 
                 if (max_row != i) {
                     for (int j = 0; j < n; ++j) {
-                        double temp_val = temp[i][j];
+                        float temp_val = temp[i][j];
                         temp[i][j] = temp[max_row][j];
                         temp[max_row][j] = temp_val;
                     }
@@ -162,7 +161,7 @@ class Mat {
                 }
 
                 for (int k = i + 1; k < n; ++k) {
-                    double factor = temp[k][i] / temp[i][i];
+                    float factor = temp[k][i] / temp[i][i];
                     for (int j = i; j < n; ++j) {
                         temp[k][j] -= factor * temp[i][j];
                     }
@@ -175,10 +174,10 @@ class Mat {
         }
 
         // cofactor for the adjugate since submatrix causes issues.
-        double coaf(size_t i, size_t j) {
+        float coaf(size_t i, size_t j) {
             Mat<m - 1, n - 1> minor;
             int minor_row = 0, minor_col = 0;
-            double sign = ((i + j) % 2 == 0) ? 1 : -1;
+            float sign = ((i + j) % 2 == 0) ? 1 : -1;
 
             for (int row = 0; row < m; ++row) {
                 if (row == i) continue;
@@ -206,27 +205,29 @@ class Mat {
 
                 for (int i = 0; i < n; ++i) {
                         for (int j = 0; j < n; ++j) {
-                            double cofactor = this->coaf(i, j);
+                            float cofactor = this->coaf(i, j);
                             adj[j][i] = cofactor;  
                         }
                     }
             return adj;
         }
 
-        Mat transpose() {
+        Mat<n, m> transpose() {
             Mat<n, m> result;
             for (size_t i = 0; i < m; ++i) {
                 for (size_t j = 0; j < n; ++j) {
-                    result[j][i] = r[i][j]; 
+                    result[j][i] = r[i][j];
                 }
             }
             return result;
         }
 
         Mat inverse() {
-            double det = this->det();
+            float det = this->det();
             if (n != m || det == 0) {
                 OS_WARN("M err inverse!");
+		scheduler_disable();
+		while(1) {}
                 return *this;
             }
             Mat adj = this->adjugate();
@@ -241,7 +242,7 @@ class Mat {
           return ret;
         }
 
-        Mat diag(double d) {
+        Mat diag(float d) {
             if (n != m)
                 OS_WARN("M diag!");
             Mat ret(*this);
@@ -262,12 +263,16 @@ class Mat {
         }
 
         void print() {
-          os_printf("Mat: \n");
+            os_putstr("Mat: \n", 6);
           for (int i = 0; i < m; ++i) {
               for (int j = 0; j < n; j++) {
-                  os_printf("%f ", r[i][j]);
+                if (r[i][j] != r[i][j])
+                    os_putstr("NaN \n", 5);
+                else
+                  os_putf(r[i][j]);
+		os_putstr(" ", 1);
               }
-              os_printf("\n");
+              os_putstr("\n", 1);
           }
         }
 
diff --git a/src/math/quaternion.h b/src/math/quaternion.h
index 3ce7c1e..2504935 100644
--- a/src/math/quaternion.h
+++ b/src/math/quaternion.h
@@ -7,10 +7,42 @@
 
 class Quaternion {
     public:
-        double q, i, j, k;
+        float q, i, j, k;
     public:
         Quaternion() : q(1), i(0), j(0), k(0) {}
-        Quaternion(double w, double i, double j, double k) : q(w), i(i), j(j), k(k) {}
+        Quaternion(float w, float i, float j, float k) : q(w), i(i), j(j), k(k) {}
+
+        Quaternion(float roll, float pitch, float yaw) {
+          float cr = cos(roll * 0.5);
+          float sr = sin(roll * 0.5);
+          float cp = cos(pitch * 0.5);
+          float sp = sin(pitch * 0.5);
+          float cy = cos(yaw * 0.5);
+          float sy = sin(yaw * 0.5);
+
+          this->q = cr * cp * cy + sr * sp * sy;
+          this->i = sr * cp * cy - cr * sp * sy;
+          this->j = cr * sp * cy + sr * cp * sy;
+          this->k = cr * cp * sy - sr * sp * cy;
+        }
+
+        Quaternion(Vec3 rpy) {
+	  float roll = rpy[0];
+	  float pitch = rpy[1];
+	  float yaw = rpy[2];
+          float cr = cos(roll * 0.5);
+          float sr = sin(roll * 0.5);
+          float cp = cos(pitch * 0.5);
+          float sp = sin(pitch * 0.5);
+          float cy = cos(yaw * 0.5);
+          float sy = sin(yaw * 0.5);
+
+          this->q = cr * cp * cy + sr * sp * sy;
+          this->i = sr * cp * cy - cr * sp * sy;
+          this->j = cr * sp * cy + sr * cp * sy;
+          this->k = cr * cp * sy - sr * sp * cy;
+        }
+
         Quaternion(const Quaternion &other) {
           this->q = other.q;
           this->i = other.i;
@@ -18,38 +50,38 @@ class Quaternion {
           this->k = other.k;
         }
 
-        Quaternion(const Vec4D &vec) {
+        Quaternion(const Vec4 &vec) {
           this->q = vec[0];
           this->i = vec[1];
           this->j = vec[2];
           this->k = vec[3];
         }
-        Quaternion(const Mat3D & mat) {
+        Quaternion(const Mat3 & mat) {
             Quaternion ret = Quaternion(1, 0, 0, 0);
 
-            double trace = mat[0][0] + mat[1][1] + mat[2][2];
+            float trace = mat[0][0] + mat[1][1] + mat[2][2];
 
             if (trace > 0) {
-                double s = 0.5 / sqrt(trace + 1);
+                float s = 0.5 / sqrt(trace + 1);
                 this->q = 0.25 / s;
                 this->i = (mat[2][1] - mat[1][2]) * s;
                 this->j = (mat[0][2] - mat[2][0]) * s;
                 this->k = (mat[1][0] - mat[0][1]) * s;
             } else {
                 if (mat[0][0] > mat[1][1] && mat[0][0] > mat[2][2]) {
-                double s = 2 * sqrt(1 + mat[0][0] - mat[1][1] - mat[2][2]);
+                float s = 2 * sqrt(1 + mat[0][0] - mat[1][1] - mat[2][2]);
                 this->q = (mat[2][1] - mat[1][2]) / s;
                 this->i = 0.25 * s;
                 this->j = (mat[0][1] + mat[1][0]) / s;
                 this->k = (mat[0][2] + mat[2][0]) / s;
             } else if (mat[1][1] > mat[2][2]) {
-                double s = 2 * sqrt(1 + mat[1][1] - mat[0][0] - mat[2][2]);
+                float s = 2 * sqrt(1 + mat[1][1] - mat[0][0] - mat[2][2]);
                 this->q = (mat[0][2] - mat[2][0]) / s;
                 this->i = (mat[0][1] + mat[1][0]) / s;
                 this->j = 0.25 * s;
                 this->k = (mat[1][2] + mat[2][1]) / s;
             } else {
-                double s = 2 * sqrt(1 + mat[2][2] - mat[0][0] - mat[1][1]);
+                float s = 2 * sqrt(1 + mat[2][2] - mat[0][0] - mat[1][1]);
                 this->q = (mat[1][0] - mat[0][1]) / s;
                 this->i = (mat[0][2] + mat[2][0]) / s;
                 this->j = (mat[1][2] + mat[2][1]) / s;
@@ -76,12 +108,12 @@ class Quaternion {
             );
         }
 
-        Quaternion operator*(const double& nbr) const{
+        Quaternion operator*(const float& nbr) const{
             return Quaternion(q * nbr, i * nbr, j * nbr, k * nbr);
         }
 
-        Quaternion operator*(const Mat4D& other) const {
-            Vec4D v;
+        Quaternion operator*(const Mat4& other) const {
+            Vec4 v;
             v[0] = this->q;
             v[1] = this->i;
             v[2] = this->j;
@@ -103,8 +135,8 @@ class Quaternion {
             return Quaternion(q, -i, -j, -k);
         }
 
-        Vec3D to_rpy() const {
-            Vec3D result;
+        Vec3 to_rpy() const {
+            Vec3 result;
             result[0] = atan2(2 * (q * i + j * k), 1 - 2 * (i * i + j * j));
             result[1] = asin(2 * (q * j - k * i));
             result[2] = atan2(2 * (q * k + i * j), 1 - 2 * (j * j + k * k));
@@ -112,16 +144,17 @@ class Quaternion {
 
         }
 
-        Vec4D to_vector() const {
-            Vec4D ret;
+        Vec4 to_vector() const {
+            Vec4 ret;
             ret[0] = q;
             ret[1] = i;
             ret[2] = j;
             ret[3] = k;
+            return ret;
         }
 
-        Mat3D to_rotation_matrix() const {
-            Mat3D result;
+        Mat3 to_rotation_matrix() const {
+            Mat3 result;
             result[0][0] = 1 - 2 * (j * j + k * k);
             result[0][1] = 2 * (i * j - k * q);
             result[0][2] = 2 * (i * k + j * q);
@@ -134,18 +167,31 @@ class Quaternion {
             return result;
         }
 
-        double norm() const {
+        float norm() const {
             return this->to_vector().norm();
         }
 
         Quaternion normalize() const {
-            double norm = this->norm();
+            float norm = this->norm();
+            if (norm == 0) norm = 1;
             return Quaternion(q / norm, i / norm, j / norm, k / norm);
         }
 
         void print() const {
-            os_printf("Quaternion: \n");
-            os_printf("q: %f, i: %f, j: %f, k: %f \n", q, i, j, k);
+            os_putstr("Quaternion: \n", 13);
+            os_putstr("q: ", 3);
+            os_putf(q);
+            os_putstr("i: ", 3);
+            os_putf(i);
+            os_putstr("j: ", 3);
+            os_putf(j);
+            os_putstr("k: ", 3);
+            os_putf(k);
+            os_putstr("\n", 1);
+        }
+
+        void print_bare() const {
+            os_printf("%f, %f, %f, %f \n", q, i, j, k);
         }
 };
 
diff --git a/src/math/vector.h b/src/math/vector.h
index 821716e..b90cce8 100644
--- a/src/math/vector.h
+++ b/src/math/vector.h
@@ -9,11 +9,11 @@
 template <size_t size>
 class Vec {
     protected:
-    double r[size]{};
+    float r[size]{};
 
     public:
         Vec () {}
-        Vec(double *arr) {
+        Vec(float *arr) {
             for (size_t i = 0; i < size; i++) {
                 r[i] = arr[i];
             }
@@ -27,7 +27,7 @@ class Vec {
 
         ~Vec() {}
 
-        Vec operator*(double d) const {
+        Vec operator*(float d) const {
             Vec result;
             for (size_t i = 0; i < size; i++) {
                 result.r[i] = r[i] * d;
@@ -35,15 +35,23 @@ class Vec {
             return result;
         }
 
-        double operator*(Vec other) const {
-            double dot_product = 0.0;
+        float operator*(Vec other) const {
+            float dot_product = 0.0;
             for (size_t i = 0; i < size; i++) {
                 dot_product += r[i] * other.r[i];
             }
             return dot_product;
         }
 
-        Vec operator/(double d) const {
+        Vec mult(Vec other) const {
+            Vec res;
+            for (size_t i = 0; i < size; i++) {
+                res[i] = this->r[i] * other.r[i];
+            }
+            return res;
+        }
+
+        Vec operator/(float d) const {
             if (d == 0) {
                 OS_WARN("Vector div by 0!");
                 return *this;
@@ -87,18 +95,18 @@ class Vec {
             return 1;
         }
 
-        const double& operator[](size_t index) const {
+        const float& operator[](size_t index) const {
             if (index >= size) OS_WARN("V err Index out of bounds");
             return r[index];
         }
 
-        double& operator[](size_t index) {
+        float& operator[](size_t index) {
             if (index >= size) OS_WARN("V err Index out of bounds");
             return r[index];
         }
 
-        double norm() const {
-            double sum = 0;
+        float norm() const {
+            float sum = 0;
             for (int i = 0; i < size; ++i) {
                 sum += this->r[i] * this->r[i];
             }
@@ -106,26 +114,38 @@ class Vec {
         }
 
         Vec normalize() {
-                double norm = this->norm();
-                if (norm == 0)
-                return Vec(size);
-                Vec ret(*this / norm);
-                return ret;
+	  float norm = this->norm();
+	  Vec<size> ret;
+	  if (norm == 0) {
+	    return ret;
+	  }
+	  ret = *this / norm;
+          return ret;
         }
 
         void print() {
-            os_printf("Vector: \n");
+            os_putstr("Vector: \n", 9);
             for (int i = 0; i < size; ++i) {
-                os_printf("%f \n", this->r[i]);
+              if (r[i] != r[i])
+                  os_putstr("NaN \n",5);
+              else {
+                os_putf(this->r[i]);
+                os_putstr("\n",1);
+              }
             }
         }
 
         void print_bare() {
             for (int i = 0; i < size - 1; ++i) {
-                os_printf("%f ,", this->r[i]);
+                if (r[i] != r[i])
+                    os_putstr("NaN \n",5);
+                else {
+                    os_putf(this->r[i]);
+                    os_putstr(", ",2);
+                }
             }
-            os_printf("%f ", this->r[size-1]);
-            os_printf("\n");
+            os_putf(this->r[size-1]);
+            os_putstr("\n",1);
         }
 };
 typedef Vec<4> Vec4;
diff --git a/todo.org b/todo.org
new file mode 100644
index 0000000..5683a14
--- /dev/null
+++ b/todo.org
@@ -0,0 +1,3 @@
+* Stuff still todo
+
+
